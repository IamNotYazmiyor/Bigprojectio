<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Optimize Edilmiş 3D Parçacık Sistemi</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; color: white; font-family: 'Inter', sans-serif; touch-action: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100dvh; z-index: 1; }
        /* Video gizli ama işlem için gerekli */
        #video-input { position: absolute; bottom: 10px; right: 10px; width: 1px; height: 1px; opacity: 0; pointer-events: none; }
        
        .ui-overlay { 
            position: absolute; top: 0; left: 0; width: 100%; padding: 20px; 
            z-index: 20; pointer-events: none; 
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }
        
        .loading-overlay { 
            position: fixed; inset: 0; background: #000; 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            z-index: 50; transition: opacity 0.5s ease; 
        }

        .gesture-pill { 
            background: rgba(255,255,255,0.1); backdrop-filter: blur(5px); 
            border: 1px solid rgba(255,255,255,0.1); padding: 6px 12px; 
            border-radius: 20px; margin-bottom: 6px; 
            display: flex; align-items: center; gap: 8px; 
            transition: all 0.3s ease; opacity: 0.6; transform: scale(0.9);
        }
        .gesture-pill.active { 
            background: rgba(0, 255, 136, 0.2); border-color: rgba(0, 255, 136, 0.5); 
            opacity: 1; transform: scale(1); box-shadow: 0 0 10px rgba(0, 255, 136, 0.2); 
        }
        .dot { width: 6px; height: 6px; border-radius: 50%; background: #999; }
        .gesture-pill.active .dot { background: #00ff88; }
        
        /* Kamera önizlemesi (Kullanıcının kendini görmesi için küçük pencere) */
        #cam-preview {
            position: absolute; bottom: 20px; right: 20px; width: 100px; height: 75px;
            background: #000; border-radius: 10px; border: 2px solid rgba(255,255,255,0.2);
            z-index: 30; overflow: hidden; transform: scaleX(-1);
        }
        #cam-preview video { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>

    <!-- Yükleniyor Ekranı -->
    <div id="loading" class="loading-overlay">
        <div class="w-12 h-12 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mb-4"></div>
        <h2 class="text-lg font-medium text-white">Sistem Başlatılıyor...</h2>
        <p class="text-gray-400 text-xs mt-2 text-center max-w-xs">Kamera izni verin.<br>Mobilde performans için düşük grafik modu devrede.</p>
    </div>

    <!-- Arayüz -->
    <div class="ui-overlay">
        <div class="flex justify-between items-start">
            <div>
                <h1 class="text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-green-400">
                    AETHER v2
                </h1>
                <p class="text-[10px] text-gray-400 mb-4">El Hareketleri veya Dokunmatik</p>
            </div>
            
            <!-- Durum Göstergesi -->
            <div id="status-badge" class="px-2 py-1 rounded bg-red-900/50 border border-red-500/30 text-[10px] text-red-200">
                Kamera Kapalı
            </div>
        </div>

        <div id="gesture-list" class="flex flex-wrap gap-2 max-w-[300px]">
            <div class="gesture-pill" data-fingers="0"><div class="dot"></div> <span class="text-xs">Yumruk: Kara Delik</span></div>
            <div class="gesture-pill" data-fingers="1"><div class="dot"></div> <span class="text-xs">1 Parmak: Kalp</span></div>
            <div class="gesture-pill" data-fingers="2"><div class="dot"></div> <span class="text-xs">2 Parmak: Satürn</span></div>
            <div class="gesture-pill" data-fingers="3"><div class="dot"></div> <span class="text-xs">3 Parmak: Çiçek</span></div>
            <div class="gesture-pill" data-fingers="4"><div class="dot"></div> <span class="text-xs">4 Parmak: DNA</span></div>
            <div class="gesture-pill active" data-fingers="5"><div class="dot"></div> <span class="text-xs">El Açık: Küre</span></div>
        </div>
    </div>

    <!-- İşlem Videosu (Gizli) -->
    <video id="video-input" playsinline></video>
    
    <!-- Önizleme Videosu (Görünür) -->
    <div id="cam-preview"></div>
    
    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <script>
        // --- Mobil Kontrolü ve Ayarlar ---
        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.innerWidth < 800;
        
        // Mobilde parçacık sayısını düşürerek kasmayı engelliyoruz
        const PARTICLE_COUNT = isMobile ? 5000 : 12000;
        const PARTICLE_SIZE = isMobile ? 0.15 : 0.08;
        const CAM_Z = isMobile ? 55 : 40; // Mobilde kamerayı geri çek
        
        let currentShape = 'sphere';
        let targetPositions = []; 
        let currentPositions = []; 
        let isHandDetected = false;
        
        // Etkileşim Değişkenleri
        let rotationX = 0;
        let rotationY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let shapeScale = 1.0;

        // --- Three.js Kurulumu ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = CAM_Z;

        const renderer = new THREE.WebGLRenderer({ antialias: !isMobile, alpha: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Mobilde pixelRatio'yu düşürerek GPU yükünü azalt
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2)); 
        container.appendChild(renderer.domElement);

        // --- Parçacık Sistemi ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        
        // Başlangıç pozisyonları
        for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 100;
            colors[i] = 1.0;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Doku oluşturma (Performans için basit)
        const canvas = document.createElement('canvas');
        canvas.width = 16; canvas.height = 16; // Küçük doku = hızlı render
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(8, 8, 0, 8, 8, 8);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 16, 16);
        const texture = new THREE.CanvasTexture(canvas);

        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            map: texture,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.9
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- Şekil Matematiği ---
        
        function getPoint(type, i, total) {
            const r = 10;
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            
            let x, y, z;

            if (type === 'sphere') {
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
            } 
            else if (type === 'heart') {
                const t = Math.random() * Math.PI * 2;
                // 3D Kalp Formülü
                x = 16 * Math.pow(Math.sin(t), 3);
                y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                z = (Math.random() - 0.5) * 4;
                // Ölçekle
                x *= 0.5; y *= 0.5; z *= 2;
            }
            else if (type === 'saturn') {
                // Halka mı gezegen mi?
                if (Math.random() > 0.4) { // Halka
                    const ang = Math.random() * Math.PI * 2;
                    const rad = 12 + Math.random() * 8;
                    x = Math.cos(ang) * rad;
                    z = Math.sin(ang) * rad;
                    y = (Math.random() - 0.5);
                } else { // Gezegen
                    x = r * 0.7 * Math.sin(phi) * Math.cos(theta);
                    y = r * 0.7 * Math.sin(phi) * Math.sin(theta);
                    z = r * 0.7 * Math.cos(phi);
                }
            }
            else if (type === 'flower') {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;
                const rad = 10 * (1 + 0.5 * Math.sin(5 * u) * Math.sin(5 * v));
                x = rad * Math.sin(v) * Math.cos(u);
                y = rad * Math.sin(v) * Math.sin(u);
                z = rad * Math.cos(v);
            }
            else if (type === 'helix') {
                const t = Math.random() * 20; 
                const strand = Math.random() > 0.5 ? 1 : -1;
                x = 5 * Math.cos(t + strand * Math.PI);
                y = (t - 10) * 2;
                z = 5 * Math.sin(t + strand * Math.PI);
            }
            else if (type === 'blackhole') {
                const ang = Math.random() * Math.PI * 2;
                const rad = Math.random() * 2; // Çok küçük, yoğun merkez
                x = Math.cos(ang) * rad;
                y = (Math.random() - 0.5) * rad;
                z = Math.sin(ang) * rad;
            }

            return {x, y, z};
        }

        const templates = {};
        const shapeNames = ['sphere', 'heart', 'saturn', 'flower', 'helix', 'blackhole'];

        function generateTemplates() {
            shapeNames.forEach(name => {
                const arr = new Float32Array(PARTICLE_COUNT * 3);
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const p = getPoint(name, i, PARTICLE_COUNT);
                    arr[i*3] = p.x;
                    arr[i*3+1] = p.y;
                    arr[i*3+2] = p.z;
                }
                templates[name] = arr;
            });
        }
        generateTemplates();
        targetPositions = templates.sphere;
        currentPositions = new Float32Array(templates.sphere);

        // --- Dokunmatik Kontroller (Touch) ---
        let touchStartX = 0;
        let touchStartY = 0;
        
        document.addEventListener('touchstart', e => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, {passive: false});

        document.addEventListener('touchmove', e => {
            // Sayfa kaydırmayı engelle
            e.preventDefault(); 
            const deltaX = e.touches[0].clientX - touchStartX;
            const deltaY = e.touches[0].clientY - touchStartY;
            
            targetRotationY += deltaX * 0.005;
            targetRotationX += deltaY * 0.005;
            
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, {passive: false});

        // --- MediaPipe El Takibi ---
        const videoElement = document.getElementById('video-input');
        const statusBadge = document.getElementById('status-badge');
        
        function onResults(results) {
            document.getElementById('loading').style.opacity = '0';
            setTimeout(() => document.getElementById('loading').style.display = 'none', 500);
            
            statusBadge.innerText = "Kamera Aktif";
            statusBadge.className = "px-2 py-1 rounded bg-green-900/50 border border-green-500/30 text-[10px] text-green-200";

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // Parmak Sayma (Daha basit ve sağlam mantık)
                let fingers = 0;
                // Başparmak (x eksenine göre kontrol)
                if (landmarks[4].x < landmarks[3].x) fingers++; // Sağ el varsayımı (ayna modu)
                // Diğer parmaklar (y ekseni - yukarıda mı?)
                if (landmarks[8].y < landmarks[6].y) fingers++;
                if (landmarks[12].y < landmarks[10].y) fingers++;
                if (landmarks[16].y < landmarks[14].y) fingers++;
                if (landmarks[20].y < landmarks[18].y) fingers++;

                // Özel durum: Yumruk (0) veya başparmak hatasını tolere et
                // Burada basitlik adına UI'ı güncelliyoruz
                updateShape(fingers);

                // El pozisyonuna göre döndürme
                const cx = landmarks[9].x; // Avuç içi x
                const cy = landmarks[9].y; // Avuç içi y
                
                // Hassaslık azaltıldı, daha yumuşak
                targetRotationY = (cx - 0.5) * 2; 
                targetRotationX = (cy - 0.5) * 2;

                // Pinch (Yakınlaştırma) Kontrolü (Başparmak ve İşaret)
                const pinchDist = Math.hypot(landmarks[4].x - landmarks[8].x, landmarks[4].y - landmarks[8].y);
                shapeScale = 0.5 + (pinchDist * 4); // 0.5 ile 2.0 arası
                
            } else {
                isHandDetected = false;
                // El yoksa yavaşça dönmeye devam et
                targetRotationY += 0.002;
            }
        }

        function updateShape(fingers) {
            let nextShape = 'sphere';
            // Parmak sayısı düzeltmeleri (bazen başparmak algılanmaz)
            if (fingers === 0) nextShape = 'blackhole';
            else if (fingers === 1) nextShape = 'heart';
            else if (fingers === 2) nextShape = 'saturn';
            else if (fingers === 3) nextShape = 'flower';
            else if (fingers === 4) nextShape = 'helix';
            else nextShape = 'sphere';

            if (currentShape !== nextShape) {
                currentShape = nextShape;
                targetPositions = templates[nextShape];
                
                // UI Güncelle
                document.querySelectorAll('.gesture-pill').forEach(el => {
                    el.classList.remove('active');
                    if(parseInt(el.dataset.fingers) === fingers) el.classList.add('active');
                    // 5 ve üzeri hepsi küre
                    if(fingers >= 5 && parseInt(el.dataset.fingers) === 5) el.classList.add('active');
                });
            }
        }

        // MediaPipe Başlatma
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: isMobile ? 0 : 1, // 0 = Lite (Hızlı), 1 = Full
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);

        // Kamera Başlatma
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: isMobile ? 320 : 640, // Mobilde düşük çözünürlük
            height: isMobile ? 240 : 480
        });
        
        cameraUtils.start().catch(e => {
            document.querySelector('#loading h2').innerText = "Kamera Hatası";
            document.querySelector('#loading p').innerText = "Lütfen izinleri kontrol edip yenileyin.";
        });

        // Kullanıcıya kendi görüntüsünü göstermek için (ayna efekti)
        const previewDiv = document.getElementById('cam-preview');
        // Video elementini klonlamak yerine, stream'i yeni bir video elementine ata
        const previewVideo = document.createElement('video');
        previewVideo.muted = true;
        previewVideo.autoplay = true;
        previewVideo.playsInline = true;
        previewDiv.appendChild(previewVideo);
        
        // Asıl video başladığında stream'i al
        videoElement.addEventListener('play', () => {
            const stream = videoElement.captureStream ? videoElement.captureStream() : videoElement.srcObject;
            if(stream) previewVideo.srcObject = stream;
            else if(videoElement.srcObject) previewVideo.srcObject = videoElement.srcObject;
        });


        // --- Animasyon Döngüsü ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Rotasyon Yumuşatma (Lerp)
            rotationX += (targetRotationX - rotationX) * 0.1;
            rotationY += (targetRotationY - rotationY) * 0.1;
            
            particles.rotation.x = rotationX;
            particles.rotation.y = rotationY;

            // Renk Hedefleri
            let tr, tg, tb;
            switch(currentShape) {
                case 'heart': tr=1; tg=0.1; tb=0.3; break; // Kırmızı
                case 'saturn': tr=1; tg=0.8; tb=0.2; break; // Sarı
                case 'flower': tr=1; tg=0.2; tb=1; break; // Pembe
                case 'helix': tr=0; tg=1; tb=0.5; break; // Yeşil/Turkuaz
                case 'blackhole': tr=0.5; tg=0; tb=0; break; // Koyu Kırmızı
                default: tr=0.2; tg=0.5; tb=1; break; // Mavi
            }

            const positionsAttribute = geometry.attributes.position;
            const colorsAttribute = geometry.attributes.color;
            const posArr = positionsAttribute.array;
            const colArr = colorsAttribute.array;

            // Morf Efekti (Performans için döngüyü basit tut)
            // Eğer mobildeysek her frame'de güncelleme yapmak zorlayabilir mi? 
            // 5000 parçacık modern telefonlarda sorun olmaz.
            
            const lerpFactor = isMobile ? 0.08 : 0.05;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                
                // Hedef Pozisyon
                let tx = targetPositions[ix] * shapeScale;
                let ty = targetPositions[ix+1] * shapeScale;
                let tz = targetPositions[ix+2] * shapeScale;

                // Hafif dalgalanma (Sadece küre veya çiçekte)
                if (currentShape !== 'blackhole' && !isMobile) {
                    tx += Math.sin(time + i) * 0.1;
                }

                // Pozisyon güncelleme
                posArr[ix] += (tx - posArr[ix]) * lerpFactor;
                posArr[ix+1] += (ty - posArr[ix+1]) * lerpFactor;
                posArr[ix+2] += (tz - posArr[ix+2]) * lerpFactor;

                // Renk güncelleme
                colArr[ix] += (tr - colArr[ix]) * 0.03;
                colArr[ix+1] += (tg - colArr[ix+1]) * 0.03;
                colArr[ix+2] += (tb - colArr[ix+2]) * 0.03;
            }

            positionsAttribute.needsUpdate = true;
            colorsAttribute.needsUpdate = true;

            renderer.render(scene, camera);
        }

        // Ekran boyutu değişirse
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            camera.aspect = width / height;
            
            // Dikey ekranda kamerayı uzaklaştır
            camera.position.z = width < height ? 55 : 40;
            
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

        animate();

    </script>
</body>
</html>



